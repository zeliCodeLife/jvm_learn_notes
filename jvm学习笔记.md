# 1.jvm整体架构

•JVM(虚拟机)：指以软件的方式模拟具有完整硬件系统功能、运行在一个完全隔离环境中的完整计算机系统 ，是物理机的软件实现。常用的虚拟机有VMWare，Virtual Box，Java Virtual Machine。jvm是用c写的，还有一点c++。

•Java虚拟机阵营：**Sun HotSpot VM、BEA JRockit VM**、IBM J9 VM、Azul VM、Apache Harmony、Google Dalvik VM、Microsoft JVM...

![image-20200514162732168](D:\gitRepo\jvm_learn_notes\jvm学习笔记.assets\image-20200514162732168.png)

JVM由三个主要的子系统构成，如下图所示

* 类加载器子系统
* 运行时数据区（内存结构）
* 执行引擎

![image-20200514225118061](D:\gitRepo\jvm_learn_notes\jvm学习笔记.assets\image-20200514225118061.png)

java文件通过javac编译成为class字节码文件。字节码文件通过类加载器加载到运行时数据区，最后由java执行引擎去执行。过程中垃圾回收器会一直回收内存区域的垃圾。

## 1.1 运行时数据区

 ![image-20200516165549384](D:\gitRepo\jvm_learn_notes\jvm学习笔记.assets\image-20200516165549384.png)

java程序是一个进程，进程里面有很多线程。对于每个java线程，独占运行时数据区的淡蓝色部分：java栈，本地方法栈，程序计数器。堆和方法区是所有java线程共享的。

•**本地方法栈****(****线程****私有****)**：登记native方法，在Execution Engine执行时加载本地方法库

•**程序计数器****（****线程****私有****）**：就是一个指针，指向方法区中的方法字节码（用来存储指向下一条指令的地址,也即将要执行的指令代码），由执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不记。

•**方法区****(****线程共享****)**：类的所有字段和方法字节码，以及一些特殊方法如构造函数，接口代码也在此定义。简单说，所有定义的方法的信息都保存在该区域，静态变量+常量+类信息(构造方法/接口定义)+运行时常量池都存在方法区中，虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。

•**Java****栈（线程****私有****）**： Java线程执行方法的内存模型，一个线程对应一个栈，每个方法在执行的同时都会创建一个栈帧（用于存储局部变量表，操作数栈，动态链接，方法出口等信息）**不存在垃圾回收问题**，只要线程一结束该栈就释放，生命周期和线程一致

### 1.1.1 栈，程序计数器

**Java栈（线程私有）**： Java线程执行方法的内存模型，一个线程对应一个栈，每个方法在执行的同时都会创建一个栈帧（用于存储**局部变量**表，**操作数**栈，动态链接，**方法出口**等信息）不存在垃圾回收问题，只要线程一结束该栈就释放，生命周期和线程一致。

案例引入：

![image-20200516170217065](D:\gitRepo\jvm_learn_notes\jvm学习笔记.assets\image-20200516170217065.png)

main函数代表java进程的主线程。里面可以理解为有三部分：栈，本地方法栈，程序计数器。

上图中的math方法，会在栈中生成属于这个方法的栈帧。一旦这个方法执行完毕，那属于这个方法的栈帧也就没有存在的必要了。从栈的角度考虑，调用一个方法就入栈一个栈帧，这个方法执行完毕了，这个栈帧就应该出栈，自然而然的就返回执行销毁栈帧对应方法的地方了。

每个栈帧中分为好几部分，列举几个主要的：局部变量表，操作数栈，动态链接，方法出口。

![image-20200516173223618](D:\gitRepo\jvm_learn_notes\jvm学习笔记.assets\image-20200516173223618.png)

* 局部变量表

![image-20200517085157883](D:\gitRepo\jvm_learn_notes\jvm学习笔记.assets\image-20200517085157883.png)

* 操作数栈

![image-20200517085204740](D:\gitRepo\jvm_learn_notes\jvm学习笔记.assets\image-20200517085204740.png)

* 动态链接

![image-20200517085218346](D:\gitRepo\jvm_learn_notes\jvm学习笔记.assets\image-20200517085218346.png)

* 方法出口

![image-20200517085228027](D:\gitRepo\jvm_learn_notes\jvm学习笔记.assets\image-20200517085228027.png)

想要分析底层的执行过程，要看到字节码层次，可以借助javap -c 来吧class文件来反汇编为可读的字节码文件。

![image-20200516173518584](D:\gitRepo\jvm_learn_notes\jvm学习笔记.assets\image-20200516173518584.png)

文件的内容截图如下：

![image-20200516173538099](D:\gitRepo\jvm_learn_notes\jvm学习笔记.assets\image-20200516173538099.png)

先简答理解一下程序计数器，永远指向下一步要执行的位置，类似一个指针。

•**程序计数器****（****线程****私有****）**：就是一个指针，指向方法区中的方法字节码（用来存储指向下一条指令的地址,也即将要执行的指令代码），由执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不记。

然后分析一下math方法：

![image-20200517075201878](D:\gitRepo\jvm_learn_notes\jvm学习笔记.assets\image-20200517075201878.png)

左侧的计数，可以理解为是程序计数器的游标所在的位置，永远指向下一句要执行的指令。

0：将int型常量1压入操作数栈。

1：将上一步的int型值放入局部变量表1的位置

2：将int型常量2压入操作数栈。

3：将上一步的int型值放入局部变量表2的位置

4：从局部变量中装载1位置的int类型值到操作数栈。

5：从局部变量中装载2位置的int类型值到操作数栈。

6：将操作数栈中的前两个数做加法运算

7：将10压入操作数栈，10也占一步指令，实际上声明10也是一步。

9：将操作数中的栈顶的2个int值做乘法

10:将乘法所得的值，放入局部变量表3的位置

11:从局部变量中装载3位置的int类型值到操作数栈。

12：返回int给调用该方法的位置。

方法出口：记录了很多返回的相关信息，除了返回地址，还有上一个main方法对应的程序计数器的值，方便恢复程序执行的现场。

动态链接：一般出现于多态场景，以map和hashmap为例，map是一个接口变量，在调用具体的方法的时候，需要去堆中找具体的实现类，让实现类去执行具体的方法，这种接口变量与实现类之间的关系就叫动态链接。

### 1.1.2 本地方法栈

•**本地方法栈****(****线程****私有****)**：登记native方法，在Execution Engine执行时加载本地方法库。

以Thread类为例，

![image-20200517081800000](D:\gitRepo\jvm_learn_notes\jvm学习笔记.assets\image-20200517081800000.png)

线程的启动会调用start0让底层去做一些事情，理解为做一些准备。

![image-20200517081850986](D:\gitRepo\jvm_learn_notes\jvm学习笔记.assets\image-20200517081850986.png)

这个方法是一个本地方法接口，他有底层实现，底层实现是c语言写的。这是java早期刚出来的时候需要替换一些已有的产品，必须兼容c语言才有的一种特性。现在本地方法的接口已经越来越少了。

![image-20200517082040707](D:\gitRepo\jvm_learn_notes\jvm学习笔记.assets\image-20200517082040707.png)

针对这种本地方法，进入的是本地方法栈，而不是java栈。执行引擎去执行的时候，会调用你c语言实现的库，这个库实现了你的本地方法接口。

### 1.1.3 方法区

•**方法区****(****线程共享****)**：类的所有字段和方法字节码，以及一些特殊方法如构造函数，接口代码也在此定义。简单说，所有定义的方法的信息都保存在该区域，静态变量+常量+类信息(构造方法/接口定义)+运行时常量池都存在方法区中，虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。

栈，堆，方法区的交互关系

![image-20200517085345965](D:\gitRepo\jvm_learn_notes\jvm学习笔记.assets\image-20200517085345965.png)

### 1.1.4 堆

![image-20200517085656741](D:\gitRepo\jvm_learn_notes\jvm学习笔记.assets\image-20200517085656741.png)

•新生区

类诞生、成长、消亡的区域，一个类在这里产生，应用，最后被垃圾回收器收集，结束生命。

新生区分为两部分： 伊甸区（Eden space）和幸存者区（Survivor pace） ，所有的类都是在伊甸区被new出来的。幸存区有两个： 0区（Survivor 0 space）和1区（Survivor 1 space）。当伊甸园的空间用完时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收**(****Minor GC****)**，将伊甸园区中的不再被其他对象所引用的对象进行销毁。然后将伊甸园中的剩余对象移动到幸存 0区。若幸存 0区也满了，再对该区进行垃圾回收，然后移动到1区，此时0区和1区进行角色转换，再出现满了的情况往对方放。那如果回收了多次（jvm默认15次）之后，就会放到老年代。如果老年代也满了就会触发full gc。

•老年区

新生区经过多次GC仍然存活的对象移动到老年区。若老年区也满了，那么这个时候将产生**MajorGC****（****FullGC****）**，进行老年区的内存清理。若老年区执行了Full GC之后发现依然无法进行对象的保存，就会产生OOM异常“OutOfMemoryError”，早期垃圾回收full gc会stw（stop the word）。

**元数据区**：**元数据区取代了永久代**(jdk1.8以前)，本质和永久代类似，都是对JVM规范中**方法区**（方法区是逻辑概念，是个规范）的实现，区别在于元数据区并不在虚拟机中，而是使用本地物理内存，永久代在虚拟机中，永久代逻辑结构上属于堆，但是物理上不属于堆，堆大小=新生代+老年代。元数据区也有可能发生OutOfMemory异常。

Jdk1.6及之前： 有永久代, 常量池在方法区

Jdk1.7：    有永久代，但已经逐步“去永久代”，常量池在堆。

Jdk1.8及之后： 无永久代，常量池在元空间。

元数据区的**动态扩展**，默认–XX:MetaspaceSize值为21MB的高水位线。一旦触及则Full GC将被触发并卸载没有用的类（类对应的类加载器不再存活），然后高水位线将会重置。新的高水位线的值取决于GC后释放的元空间。如果释放的空间少，这个高水位线则上升。如果释放空间过多，则高水位线下降。

为什么jdk1.8用元数据区取代了永久代？

官方解释：移除永久代是为融合HotSpot JVM与 **JRockit VM（最后斗争最后赢了，结果高斯林出走google）**而做出的努力，因为JRockit没有永久代，不需要配置永久代。

**jvm调优的目的**：让full的次数变少，而且时间越短越好。

## 1.2 执行引擎

![image-20200517120116671](D:\gitRepo\jvm_learn_notes\jvm学习笔记.assets\image-20200517120116671.png)

JIT编译器：即时编译。just in time。

目标代码就是101010这种。执行引擎把字节码变成机器码。

just in time 是第一次执行慢，第一次就需要把100（不是具体的数字）行代码全部变成目标代码。但是解释完之后，后面就快了。

但是字节码解释器，每次都匀速，第一次比JIT编译器要快，但是以后就不行了。

默认的java使用的是混合执行的方式，如下图：

![image-20200517122847544](D:\gitRepo\jvm_learn_notes\jvm学习笔记.assets\image-20200517122847544.png)



